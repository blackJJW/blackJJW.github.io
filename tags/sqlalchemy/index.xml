<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sqlalchemy :: Tag :: Black_JJW&#39;s Blog</title>
    <link>https://blackjjw.github.io/tags/sqlalchemy/index.html</link>
    <description></description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://blackjjw.github.io/tags/sqlalchemy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>5. Database Connection Management</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/databaseconnmng/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/databaseconnmng/index.html</guid>
      <description>In this section, I’ll explain how I configured SQLAlchemy for managing database connections and sessions in a reusable and scalable way.&#xA;1. Purposes of this Management Use SQLAlchemy for ORM-based database interaction Create a reusable engine and session maker Why SQLAlchemy? I chose SQLAlchemy because it is one of the most powerful and flexible ORM libraries in Python. It allows me to:&#xA;Interact with the database using Python classes instead of raw SQL Write reusable, composable queries using the SQL Expression Language Manage sessions, transactions, and connection pooling efficiently Support multiple database backends (e.g., PostgreSQL, SQLite, MySQL) This flexibility makes it ideal for a project like this where maintainability and scalability are important.</description>
    </item>
    <item>
      <title>6. Login</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/login/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/login/index.html</guid>
      <description>In this section, I’ll explain how I made the login function. This project is designed as a single-user program. In other words, only the administrator is authorized to access and operate the system. Therefore, I created a single account with the ID: “admin”.&#xA;1. The design of the login function 1.1 Diagram This shows the communication between the frontend, backend, and DB.</description>
    </item>
    <item>
      <title>8. Login Log</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/loginlog/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/loginlog/index.html</guid>
      <description>In this section, I’ll explain how I implemented the login log functionality. Since this is a single-user application, logging each login might seem unnecessary at first. However, I decided to build this feature to enhance security and maintain visibility over all login activities. Recording login attempts allows me to track unauthorized access or unexpected behavior in the system.&#xA;1. The design of the login log function 1.1 Diagram The diagram below illustrates the communication flow between the frontend, backend, and Database during a login process.</description>
    </item>
    <item>
      <title>9. Refactoring 1: Backend - Separate AuthService and Move Login API</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/refactor1/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/refactor1/index.html</guid>
      <description>This refactoring was performed to improve separation of concerns and make authentication logic more modular and testable.&#xA;Previously, authentication logic (authenticate_user) was part of the UserService, tightly coupling user management and auth logic.&#xA;Now, that logic has been moved into a dedicated AuthService, and the login route has been migrated from user_router to a new auth_router.&#xA;1. AuthService I extracted a new service class for authentication. The authenticate_user() method, previously in UserService, is now moved to AuthService.</description>
    </item>
    <item>
      <title>10. Managing API Keys - Backend Implementation</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/mngapikeys1/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/mngapikeys1/index.html</guid>
      <description>Managing API Keys from multiple exchanges requires both exchange metadata management and secure key storage. In this post, I describe the database schema and service logic used to support this.&#xA;1. The Design of the API Key Management System 1.1 ERD The functionality is based on three relational tables: TB_USER, TB_EXCHANGES, and TB_EXCHANGE_API_KEYS.&#xA;TB_EXCHANGES stores registered exchanges.&#xA;exchange_id: Unique exchange identifier exchange_name: Name of the exchange TB_EXCHANGE_API_KEYS manages the API keys linked to exchanges per user.</description>
    </item>
    <item>
      <title>12. Refactoring 2: Backend - Applying Async Database Management</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/refactor2/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/refactor2/index.html</guid>
      <description>This refactoring adopts asynchronous database management to avoid blocking caused by synchronous I/O.&#xA;Previously, database access was implemented synchronously across services and endpoints, which could block under concurrent workloads. Because this program needs to perform multiple tasks simultaneously, I decided to switch to an async-first approach for database operations.&#xA;1. Config To enable asynchronous PostgreSQL support, install asyncpg:&#xA;uv pip install asyncpg In config.py, I added the following property to build the async SQLAlchemy URL for PostgreSQL:</description>
    </item>
    <item>
      <title>15. FastAPI Service Architecture: Thin Routers, Service Layer, and DTO Patterns</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/fastapservicearch/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/fastapservicearch/index.html</guid>
      <description>Compared to previous dev logs, this post is more of a short guideline summarizing the architecture decisions I’m applying across the backend.&#xA;As the backend grows, the number of endpoints increases as well. I started to worry that the codebase would become harder to navigate and maintain. To keep the structure clear, I adopted a layered architecture: a thin router/controller layer on top of a service layer, with DTOs at the API boundary.</description>
    </item>
    <item>
      <title>16. Idempotency and Replay Safety for Trade Execution Endpoints</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/idempotencyreplaysafety/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/idempotencyreplaysafety/index.html</guid>
      <description>Retries are inevitable in a multi-service system. HTTP timeouts, worker restarts, and upstream retries can cause the same trade ingestion payload to arrive more than once. Without idempotency, I risk double-writing trades and corrupting downstream analytics.&#xA;1. Where idempotency lives in the backend Below is simplified pseudocode that reflects my current flow:&#xA;# router: /internal-api/coinone-worker/public/trades @router.get(&#34;/trades&#34;) async def fetch_trades(quote, target, db, http_client): payload = await fetch_go_worker_trades(http_client, quote, target) summary = await TradesService(db).ingest_payload( exchange_name=&#34;coinone&#34;, quote_currency=quote, target_currency=target, payload=payload, on_conflict=&#34;nothing&#34;, ) return summary # service: TradesService.ingest_payload async def ingest_payload(exchange_name, quote_currency, target_currency, payload, on_conflict): exchange_id = ExchangesService(db).get_exchange_id(exchange_name) pair_no = CurrencyPairService(db).get_or_create_pair_no(quote_currency, target_currency) rows = normalize_transactions(payload, exchange_id, pair_no) # map &amp; validate inserted = bulk_upsert_trades(rows, on_conflict) # idempotent insert return { &#34;exchange_id&#34;: exchange_id, &#34;currency_pair_no&#34;: pair_no, &#34;inserted&#34;: inserted, &#34;attempted&#34;: len(rows), &#34;skipped&#34;: len(rows) - inserted, } At the database level, a unique constraint provides replay safety.</description>
    </item>
    <item>
      <title>17. Testing Async Services in FastAPI: pytest‑asyncio Fixtures and Mocks</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/testingasyncfastapi/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/testingasyncfastapi/index.html</guid>
      <description>As the backend moved to async services, I needed tests that were both fast and reliable. The goal was simple: validate service logic without spinning up an HTTP server or relying on external dependencies. This post documents the patterns that work well in this codebase: pytest-asyncio fixtures for async SQLAlchemy sessions and targeted mocks for service dependencies.&#xA;1. Enable async tests with pytest-asyncio This repo uses pytest-asyncio in auto mode:</description>
    </item>
  </channel>
</rss>