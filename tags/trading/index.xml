<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Trading :: Tag :: Black_JJW&#39;s Blog</title>
    <link>https://blackjjw.github.io/tags/trading/index.html</link>
    <description></description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://blackjjw.github.io/tags/trading/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>16. Idempotency and Replay Safety for Trade Execution Endpoints</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/idempotencyreplaysafety/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/idempotencyreplaysafety/index.html</guid>
      <description>Retries are inevitable in a multi-service system. HTTP timeouts, worker restarts, and upstream retries can cause the same trade ingestion payload to arrive more than once. Without idempotency, I risk double-writing trades and corrupting downstream analytics.&#xA;1. Where idempotency lives in the backend Below is simplified pseudocode that reflects my current flow:&#xA;# router: /internal-api/coinone-worker/public/trades @router.get(&#34;/trades&#34;) async def fetch_trades(quote, target, db, http_client): payload = await fetch_go_worker_trades(http_client, quote, target) summary = await TradesService(db).ingest_payload( exchange_name=&#34;coinone&#34;, quote_currency=quote, target_currency=target, payload=payload, on_conflict=&#34;nothing&#34;, ) return summary # service: TradesService.ingest_payload async def ingest_payload(exchange_name, quote_currency, target_currency, payload, on_conflict): exchange_id = ExchangesService(db).get_exchange_id(exchange_name) pair_no = CurrencyPairService(db).get_or_create_pair_no(quote_currency, target_currency) rows = normalize_transactions(payload, exchange_id, pair_no) # map &amp; validate inserted = bulk_upsert_trades(rows, on_conflict) # idempotent insert return { &#34;exchange_id&#34;: exchange_id, &#34;currency_pair_no&#34;: pair_no, &#34;inserted&#34;: inserted, &#34;attempted&#34;: len(rows), &#34;skipped&#34;: len(rows) - inserted, } At the database level, a unique constraint provides replay safety.</description>
    </item>
    <item>
      <title>20. Designing resilient exchange adapters (rate limits, errors, retries)</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/designingrestclientexchangeadapters/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/designingrestclientexchangeadapters/index.html</guid>
      <description>Exchange APIs are noisy and unpredictable. A REST client adapter has to survive timeouts, bursty traffic, bad payloads, and temporary upstream failures without corrupting data or overwhelming the system.&#xA;This post outlines the baseline approach in this project and the patterns I’m standardizing for exchange adapters.&#xA;1. The shape of an adapter in this project In this backend, exchange data is fetched via a Go worker, and the FastAPI service acts as a gateway and ingestor:</description>
    </item>
    <item>
      <title>21. WebSockets vs polling for live price updates in crypto apps</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/websocketsvspolling/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/websocketsvspolling/index.html</guid>
      <description>Live price updates are the heartbeat of a crypto app. The question isn’t “real-time or not,” but how to deliver updates reliably: WebSockets, polling, or a hybrid.&#xA;This post compares both approaches and frames the choice using the current stack in this project.&#xA;1. The two delivery models 1.1 Polling The client requests price data every N seconds. Simple to implement and easy to cache. Scales well with stateless HTTP. 1.2 WebSockets The server pushes updates continuously. Lower latency and smoother UI. Requires persistent connections and additional infrastructure. 2. What polling looks like in this repo In this repo, the backend exposes polling-style endpoints that fetch data from the Go worker and persist it.</description>
    </item>
    <item>
      <title>23. Async trading workflows: handling long‑running tasks and retries</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/asynctradingworkflows/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/asynctradingworkflows/index.html</guid>
      <description>Trading backends rarely run only “fast” requests. Market data ingestion, reconciliation jobs, and downstream calls can all be long-running or flaky. In this project, I lean on async workflows, explicit retries, and idempotent writes to keep things safe and responsive.&#xA;This post documents the current patterns and the direction for larger async jobs.&#xA;1. Async everywhere, with clean lifecycle management The FastAPI app uses an async lifespan to initialize and shut down shared dependencies:</description>
    </item>
  </channel>
</rss>