<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python :: Tag :: Black_JJW&#39;s Blog</title>
    <link>https://blackjjw.github.io/tags/python/index.html</link>
    <description></description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://blackjjw.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1. Project Initialization</title>
      <link>https://blackjjw.github.io/projects/multi-crypto-trading-tool/initializeproject/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/projects/multi-crypto-trading-tool/initializeproject/index.html</guid>
      <description>In fact, I had been working on a similar project for some time. Although I tried to complete it, I eventually gave up because it was too complex and inefficient to move forward with. So I decided to restart the project from scratch.&#xA;1. Project Tech Stack Area Tech Backend Python(FastAPI), Redis, Redis Queue(RQ), PostgreSQL Frontend React + Vite Infra Docker, Docker Compose, .env, .yml 2. Backend Settings 2.1 backend.DockerFile This DockerFile installs backend system dependencies and Python packaging tool(uv) for the Python 3.12.11 environment.</description>
    </item>
    <item>
      <title>2. Setting Up the Backend</title>
      <link>https://blackjjw.github.io/projects/multi-crypto-trading-tool/startbackend/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/projects/multi-crypto-trading-tool/startbackend/index.html</guid>
      <description>1. Installing FastAPI We will use FastAPI as the backend server framework due to its performance and asynchronous capabilities - it’s a better fit than the Flask for real-time and modular systems. Install it along with the ASGI server uvicorn using uv: uv pip install &#34;fastapi[all]&#34; uvicorn fastapi[all] : Installs optional dependencies such as: pydantic, httpx, python-multipart, jinja2, email-validator uvicorn : Lightweight ASGI server used to run FastAPI applications 2. Setting the Lifespan in FastAPI To manage startup and shutdown tasks (e.g., initializing connections, cleaning resources), FastAPI provides a lifespan context manager. from fastapi import FastAPI from contextlib import asynccontextmanager @asynccontextmanager async def lifespan(app: FastAPI): # startup print(&#34;Starting up&#34;) yield # shutdown print(&#34;Shutting down&#34;) app = FastAPI(lifespan=lifespan) This function is called once during the application’s lifecycle: Before the first request is processed (startup) After the server shuts down (cleanup) Using lifespan() is useful for: Performance optimization Test stability (isolated setup/teardown) Clean resource management (DB, queues, sockets) @asynccontextmanager: This decorator from the contextlib module allows defining an asynchronous context manager using async def. It enables setup and cleanup logic around the yield statement, and is used here to control the FastAPI application’s lifespan events (startup and shutdown). 2.1 Execution Output When running the application with uv run main.py, you can see the startup and shutdown messages handled by the lifespan() function:</description>
    </item>
    <item>
      <title>3. Logger Configuration</title>
      <link>https://blackjjw.github.io/projects/multi-crypto-trading-tool/loggerconfig/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/projects/multi-crypto-trading-tool/loggerconfig/index.html</guid>
      <description>For operating this project reliably, I need a robust logging system. So I decided the Loguru library for its simplicity and powerful features. The configuration was customized to meet the following requirements:&#xA;Custom Log Formatting Example: 2025-06-26 23:09:24 | INFO | main :lifespan :16 - Starting up the application... Persistent Log Files Save logs using filenames that include the current date. Retain logs for 7 days only. Integration with FastAPI and Uvicorn Logs Ensure logs from FastAPI, Uvicorn, and Starlette are captured uniformly 1. Pseudocode Summary IF LogConfigurator not configured: - Create log directory - Remove default handlers - Add colored console logger - Add rotating file logger - Setup InterceptHandler for uvicorn/starlette/fastapi loggers - Mark as configured 2. How I Configured the Logger To satisfy the logging requirements mentioned above, I built a singleton LogConfigurator using Loguru, which includes: 2.1 Installing loguru First, install Loguru using uv: uv install loguru 2.2 Singleton Pattern I wanted to ensure that the logger is configured only once, even if multiple modules try to initialize it. The class uses a standard __new__ pattern to maintain a single instance. def __new__(cls, *args, **kwargs): if cls._instance is None: cls._instance = super().__new__(cls) return cls._instance 2.3 Log File Management Each log file is automatically named using the current date and saved under /backend/logs. I use Loguru’s built-in rotation and retention to: Create a new file every day at midnight Retain logs only for 7 days Avoid manual cleanup logger.add( str(self.log_file), rotation=&#34;00:00&#34;, # Daily rotation retention=&#34;7 days&#34;, # Keep logs for 7 days encoding=&#34;utf-8&#34;, level=&#34;INFO&#34;, ... ) 2.4 Console Output with Colors Loguru’s colorize=True option lets me apply colors to console logs, improving readability during development. logger.add( sys.stdout, level=&#34;INFO&#34;, colorize=True, format=&#34;&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss}&lt;/green&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;cyan&gt;{name: &lt;20}&lt;/cyan&gt;:&lt;cyan&gt;{function: &lt;15}&lt;/cyan&gt;:&lt;cyan&gt;{line: &lt;4}&lt;/cyan&gt; - &lt;level&gt;{message}&lt;/level&gt;&#34;, ) 2.5 Intercepting FastAPI/Uvicorn Logs By default, FastAPI and Uvicorn use the built-in logging module. To unify all logs under Loguru, I wrote a custom InterceptHandler which: Captures standard logging logs Redirects them to Loguru with correct context (function name, line number, etc.) logging.basicConfig( handlers=[InterceptHandler()], level=logging.INFO, force=True ) I explicitly intercept common loggers: loggers_to_intercept = [ &#34;uvicorn&#34;, &#34;uvicorn.access&#34;, &#34;uvicorn.error&#34;, &#34;fastapi&#34;, &#34;starlette&#34;, &#34;starlette.routing&#34;, ] 2.6 Execution Outputs</description>
    </item>
  </channel>
</rss>