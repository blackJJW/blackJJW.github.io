<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database :: Tag :: Black_JJW&#39;s Blog</title>
    <link>https://blackjjw.github.io/tags/database/index.html</link>
    <description></description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://blackjjw.github.io/tags/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>5. Database Connection Management</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/databaseconnmng/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/databaseconnmng/index.html</guid>
      <description>In this section, Iâ€™ll explain how I configured SQLAlchemy for managing database connections and sessions in a reusable and scalable way.&#xA;1. Purposes of this Management Use SQLAlchemy for ORM-based database interaction Create a reusable engine and session maker Why SQLAlchemy? I chose SQLAlchemy because it is one of the most powerful and flexible ORM libraries in Python. It allows me to:&#xA;Interact with the database using Python classes instead of raw SQL Write reusable, composable queries using the SQL Expression Language Manage sessions, transactions, and connection pooling efficiently Support multiple database backends (e.g., PostgreSQL, SQLite, MySQL) This flexibility makes it ideal for a project like this where maintainability and scalability are important.</description>
    </item>
    <item>
      <title>12. Refactoring 2: Backend - Applying Async Database Management</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/refactor2/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/refactor2/index.html</guid>
      <description>This refactoring adopts asynchronous database management to avoid blocking caused by synchronous I/O.&#xA;Previously, database access was implemented synchronously across services and endpoints, which could block under concurrent workloads. Because this program needs to perform multiple tasks simultaneously, I decided to switch to an async-first approach for database operations.&#xA;1. Config To enable asynchronous PostgreSQL support, install asyncpg:&#xA;uv pip install asyncpg In config.py, I added the following property to build the async SQLAlchemy URL for PostgreSQL:</description>
    </item>
  </channel>
</rss>