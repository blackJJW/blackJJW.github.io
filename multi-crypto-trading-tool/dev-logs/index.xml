<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dev Logs :: Black_JJW&#39;s Blog</title>
    <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/index.html</link>
    <description>This section contains various development logs:&#xA;1. Project Initialization 2. Start Backend 3. Logger Configuration 4. Set Configuration 5. Database Connection Manager 6. Login Page Setup 7. Topbar Menu 8. Login Log 9. Refactoring 1: Backend - Separate AuthService and Move Login API 10. Managing API Keys - Backend Implementation 11. Managing API Keys - Frontend Implementation 12. Refactoring 2: Backend - Applying Async Database Management 13. Login Log - Frontend 14. Makefile Setup 15. FastAPI Service Architecture: Thin Routers, Service Layer, and DTO Patterns 16. Idempotency and Replay Safety for Trade Execution Endpoints 17. Testing Async Services in FastAPI: pytest‑asyncio Fixtures and Mocks 18. Securing API keys and secrets with Pydantic settings + .env 19. Observability for trading systems: logging, metrics, and tracing basics</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1. Project Initialization</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/initializeproject/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/initializeproject/index.html</guid>
      <description>In fact, I had been working on a similar project for some time. Although I tried to complete it, I eventually gave up because it was too complex and inefficient to move forward with. So I decided to restart the project from scratch.&#xA;1. Project Tech Stack Area Tech Backend Python(FastAPI), Redis, Redis Queue(RQ), PostgreSQL Frontend React + Vite Infra Docker, Docker Compose, .env, .yml 2. Backend Settings 2.1 backend.DockerFile This DockerFile installs backend system dependencies and Python packaging tool(uv) for the Python 3.12.11 environment.</description>
    </item>
    <item>
      <title>2. Setting Up the Backend</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/startbackend/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/startbackend/index.html</guid>
      <description>1. Installing FastAPI We will use FastAPI as the backend server framework due to its performance and asynchronous capabilities - it’s a better fit than the Flask for real-time and modular systems. Install it along with the ASGI server uvicorn using uv:&#xA;uv pip install &#34;fastapi[all]&#34; uvicorn fastapi[all] : Installs optional dependencies such as: pydantic, httpx, python-multipart, jinja2, email-validator uvicorn : Lightweight ASGI server used to run FastAPI applications 2. Setting the Lifespan in FastAPI To manage startup and shutdown tasks (e.g., initializing connections, cleaning resources), FastAPI provides a lifespan context manager.</description>
    </item>
    <item>
      <title>3. Logger Configuration</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/loggerconfig/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/loggerconfig/index.html</guid>
      <description>For operating this project reliably, I need a robust logging system. So I decided the Loguru library for its simplicity and powerful features. The configuration was customized to meet the following requirements:&#xA;Custom Log Formatting Example:&#xA;2025-06-26 23:09:24 | INFO | main :lifespan :16 - Starting up the application... Persistent Log Files&#xA;Save logs using filenames that include the current date. Retain logs for 7 days only. Integration with FastAPI and Uvicorn Logs</description>
    </item>
    <item>
      <title>4. Set Configurations</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/setconfig/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/setconfig/index.html</guid>
      <description>I used a .env file to store configuration values. To load them into the application, I’m using BaseSettings from the pydantic_settings package.&#xA;Here’s an sample .env file used to configure the PostgreSQL database connection:&#xA;POSTGRES_HOST=localhost POSTGRES_PORT=5432 POSTGRES_USER=myuser POSTGRES_PASSWORD=secret POSTGRES_DB=cryptobot 1. Settings pydantic_settings.BaseSettings is an extended version of Pydantic’s model designed for managing environment variables.&#xA;It’s commonly used in Python backend frameworks like FastAPI to load and validate environment variables.</description>
    </item>
    <item>
      <title>5. Database Connection Management</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/databaseconnmng/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/databaseconnmng/index.html</guid>
      <description>In this section, I’ll explain how I configured SQLAlchemy for managing database connections and sessions in a reusable and scalable way.&#xA;1. Purposes of this Management Use SQLAlchemy for ORM-based database interaction Create a reusable engine and session maker Why SQLAlchemy? I chose SQLAlchemy because it is one of the most powerful and flexible ORM libraries in Python. It allows me to:&#xA;Interact with the database using Python classes instead of raw SQL Write reusable, composable queries using the SQL Expression Language Manage sessions, transactions, and connection pooling efficiently Support multiple database backends (e.g., PostgreSQL, SQLite, MySQL) This flexibility makes it ideal for a project like this where maintainability and scalability are important.</description>
    </item>
    <item>
      <title>6. Login</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/login/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/login/index.html</guid>
      <description>In this section, I’ll explain how I made the login function. This project is designed as a single-user program. In other words, only the administrator is authorized to access and operate the system. Therefore, I created a single account with the ID: “admin”.&#xA;1. The design of the login function 1.1 Diagram This shows the communication between the frontend, backend, and DB.</description>
    </item>
    <item>
      <title>7. Topbar Menu</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/topbarmenu/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/topbarmenu/index.html</guid>
      <description>In this section, I’ll explain how I implemented the topbar menu. I implemented this menu to test and operate various functions between backend and the worker services.&#xA;1. The design of the Topbar Menu To keep things simple, I used react-bootstrap for the UI components, as I’m not currently focused on visual design. I’ll improve the visual styling in a future version after completing version 1 of this project. The topbar includes a set of menu items and a logout button. 1.1 Topbar Menu Structure To visualize the layout, I created a simple diagram of the topbar menu.</description>
    </item>
    <item>
      <title>8. Login Log</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/loginlog/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/loginlog/index.html</guid>
      <description>In this section, I’ll explain how I implemented the login log functionality. Since this is a single-user application, logging each login might seem unnecessary at first. However, I decided to build this feature to enhance security and maintain visibility over all login activities. Recording login attempts allows me to track unauthorized access or unexpected behavior in the system.&#xA;1. The design of the login log function 1.1 Diagram The diagram below illustrates the communication flow between the frontend, backend, and Database during a login process.</description>
    </item>
    <item>
      <title>9. Refactoring 1: Backend - Separate AuthService and Move Login API</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/refactor1/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/refactor1/index.html</guid>
      <description>This refactoring was performed to improve separation of concerns and make authentication logic more modular and testable.&#xA;Previously, authentication logic (authenticate_user) was part of the UserService, tightly coupling user management and auth logic.&#xA;Now, that logic has been moved into a dedicated AuthService, and the login route has been migrated from user_router to a new auth_router.&#xA;1. AuthService I extracted a new service class for authentication. The authenticate_user() method, previously in UserService, is now moved to AuthService.</description>
    </item>
    <item>
      <title>10. Managing API Keys - Backend Implementation</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/mngapikeys1/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/mngapikeys1/index.html</guid>
      <description>Managing API Keys from multiple exchanges requires both exchange metadata management and secure key storage. In this post, I describe the database schema and service logic used to support this.&#xA;1. The Design of the API Key Management System 1.1 ERD The functionality is based on three relational tables: TB_USER, TB_EXCHANGES, and TB_EXCHANGE_API_KEYS.&#xA;TB_EXCHANGES stores registered exchanges.&#xA;exchange_id: Unique exchange identifier exchange_name: Name of the exchange TB_EXCHANGE_API_KEYS manages the API keys linked to exchanges per user.</description>
    </item>
    <item>
      <title>11. Managing API Keys - Frontend Implementation</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/mngapikeys2/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/mngapikeys2/index.html</guid>
      <description>This post outlines the frontend design and implementation for API key management.&#xA;1. The design of the API Key Management 1.1 API Key Management Structure To visualize the layout, I sketched a simple diagram of the API Key management page.&#xA;Left-side Menu Items: Under Settings, several submenus are available.&#xA;Exchanges: Area for managing exchanges.&#xA;API Keys: Area for managing API keys.</description>
    </item>
    <item>
      <title>12. Refactoring 2: Backend - Applying Async Database Management</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/refactor2/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/refactor2/index.html</guid>
      <description>This refactoring adopts asynchronous database management to avoid blocking caused by synchronous I/O.&#xA;Previously, database access was implemented synchronously across services and endpoints, which could block under concurrent workloads. Because this program needs to perform multiple tasks simultaneously, I decided to switch to an async-first approach for database operations.&#xA;1. Config To enable asynchronous PostgreSQL support, install asyncpg:&#xA;uv pip install asyncpg In config.py, I added the following property to build the async SQLAlchemy URL for PostgreSQL:</description>
    </item>
    <item>
      <title>13. Login Log - Frontend</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/frontendloginlog/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/frontendloginlog/index.html</guid>
      <description>This article follows [8. Login Log] and [11. Managing API Keys — Frontend Implementation]. Previously, I implemented the backend for the login log. Here, I cover the frontend implementation.&#xA;1. Login Log Menu Structure To visualize the layout, I created a simple diagram of the login log menu. The current project’s login log menu is shown above.&#xA;Left-side menu items: Under Logs, several submenus are available. Login logs table: Displays login attempts. The sidebar stays fixed on the left, and the table area renders on the right.</description>
    </item>
    <item>
      <title>14. Makefile Setup</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/makefilesetup/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/makefilesetup/index.html</guid>
      <description>This project consists of multiple languages, so each one has its own set of commands. I often mix them up. To address this, I decided to add a Makefile for each language. Using Makefiles helps keep command execution consistent across languages.&#xA;1. Makefile in the Backend This Makefile is for Python with uv.&#xA;# basic target .PHONY: run freeze test # Start FastAPI server run: uv run src/main.py # Update requirements.txt freeze: uv pip freeze &gt; requirements.txt test: PYTHONPATH=./src uv run -m pytest 2. Makefile in the Frontend This Makefile is for React with npm.</description>
    </item>
    <item>
      <title>15. FastAPI Service Architecture: Thin Routers, Service Layer, and DTO Patterns</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/fastapservicearch/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/fastapservicearch/index.html</guid>
      <description>Compared to previous dev logs, this post is more of a short guideline summarizing the architecture decisions I’m applying across the backend.&#xA;As the backend grows, the number of endpoints increases as well. I started to worry that the codebase would become harder to navigate and maintain. To keep the structure clear, I adopted a layered architecture: a thin router/controller layer on top of a service layer, with DTOs at the API boundary.</description>
    </item>
    <item>
      <title>16. Idempotency and Replay Safety for Trade Execution Endpoints</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/idempotencyreplaysafety/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/idempotencyreplaysafety/index.html</guid>
      <description>Retries are inevitable in a multi-service system. HTTP timeouts, worker restarts, and upstream retries can cause the same trade ingestion payload to arrive more than once. Without idempotency, I risk double-writing trades and corrupting downstream analytics.&#xA;1. Where idempotency lives in the backend Below is simplified pseudocode that reflects my current flow:&#xA;# router: /internal-api/coinone-worker/public/trades @router.get(&#34;/trades&#34;) async def fetch_trades(quote, target, db, http_client): payload = await fetch_go_worker_trades(http_client, quote, target) summary = await TradesService(db).ingest_payload( exchange_name=&#34;coinone&#34;, quote_currency=quote, target_currency=target, payload=payload, on_conflict=&#34;nothing&#34;, ) return summary # service: TradesService.ingest_payload async def ingest_payload(exchange_name, quote_currency, target_currency, payload, on_conflict): exchange_id = ExchangesService(db).get_exchange_id(exchange_name) pair_no = CurrencyPairService(db).get_or_create_pair_no(quote_currency, target_currency) rows = normalize_transactions(payload, exchange_id, pair_no) # map &amp; validate inserted = bulk_upsert_trades(rows, on_conflict) # idempotent insert return { &#34;exchange_id&#34;: exchange_id, &#34;currency_pair_no&#34;: pair_no, &#34;inserted&#34;: inserted, &#34;attempted&#34;: len(rows), &#34;skipped&#34;: len(rows) - inserted, } At the database level, a unique constraint provides replay safety.</description>
    </item>
    <item>
      <title>17. Testing Async Services in FastAPI: pytest‑asyncio Fixtures and Mocks</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/testingasyncfastapi/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/testingasyncfastapi/index.html</guid>
      <description>As the backend moved to async services, I needed tests that were both fast and reliable. The goal was simple: validate service logic without spinning up an HTTP server or relying on external dependencies. This post documents the patterns that work well in this codebase: pytest-asyncio fixtures for async SQLAlchemy sessions and targeted mocks for service dependencies.&#xA;1. Enable async tests with pytest-asyncio This repo uses pytest-asyncio in auto mode:</description>
    </item>
    <item>
      <title>18. Securing API keys and secrets with Pydantic settings &#43; .env</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/securingapikeyandsecrets/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/securingapikeyandsecrets/index.html</guid>
      <description>Secrets are easy to leak when the project grows. In this backend, I keep configuration and credentials centralized in a Pydantic Settings class and load them from .env. API keys are encrypted at rest, and JWT secrets never live in code.&#xA;This post documents the exact pattern used in this repo.&#xA;1. Centralized config with Pydantic settings All secrets are defined once in Settings and imported through a single settings instance:</description>
    </item>
    <item>
      <title>19. Observability for trading systems: logging, metrics, and tracing basics</title>
      <link>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/observabilityfortradingsystems/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://blackjjw.github.io/multi-crypto-trading-tool/dev-logs/observabilityfortradingsystems/index.html</guid>
      <description>Trading systems are noisy and time-sensitive. When something goes wrong—missed ticks, delayed jobs, failed API calls—you need answers fast. Observability is the safety net: logs for context, metrics for trends, and tracing for end-to-end visibility.&#xA;This post documents the baseline observability setup in this repo and how it maps to real production concerns.&#xA;1. Logging: structured, centralized, and consistent The backend uses Loguru as the primary logger, with a custom configurator to capture both Loguru logs and standard Python logging.</description>
    </item>
  </channel>
</rss>